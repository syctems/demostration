!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	.\test.cpp	/^class A$/;"	c	file:
COORDIN_H_	.\coordin.h	2;"	d
Customer	.\queue.h	/^    Customer() { arrive = processtime = 0;}$/;"	f	class:Customer
Customer	.\queue.h	/^class Customer$/;"	c
Debt	.\namesp.h	/^    struct Debt$/;"	s	namespace:debts
Item	.\queue.h	/^typedef Customer Item;$/;"	t
MIN_PER_HR	.\bank.cpp	/^const int MIN_PER_HR = 60;$/;"	v
NUM	.\hangman.cpp	/^const int NUM = 26;$/;"	v
Node	.\queue.h	/^    struct Node { Item item; struct Node * next;};$/;"	s	class:Queue
Person	.\namesp.h	/^    struct Person$/;"	s	namespace:pers
QUEUE_H_	.\queue.h	2;"	d
Q_SIZE	.\queue.h	/^    enum { Q_SIZE = 10};$/;"	e	enum:Queue::__anon1
Queue	.\queue.cpp	/^Queue::Queue(int qs) : qsize(qs)$/;"	f	class:Queue
Queue	.\queue.h	/^    Queue(const Queue & q):qsize(0){}$/;"	f	class:Queue
Queue	.\queue.h	/^class Queue$/;"	c
STOCK00_H_	.\stock00.h	2;"	d
STRNGBAD_H_	.\stmgbad.h	3;"	d
Stock	.\stock00.h	/^class Stock$/;"	c
StringBad	.\stmgbad.cpp	/^StringBad::StringBad()$/;"	f	class:StringBad
StringBad	.\stmgbad.cpp	/^StringBad::StringBad(const char * s)$/;"	f	class:StringBad
StringBad	.\stmgbad.h	/^class StringBad$/;"	c
a	.\test.cpp	/^        int a;$/;"	m	class:A	file:
accumulate	.\strc_ref.cpp	/^free_throws & accumulate(free_throws & target,const free_throws & source)$/;"	f
acquire	.\stock00.cpp	/^void Stock::acquire(const std::string & co,long n,double pr)$/;"	f	class:Stock
amount	.\namesp.h	/^        double amount;$/;"	m	struct:debts::Debt
angle	.\coordin.h	/^    double angle;$/;"	m	struct:polar
another	.\namessp.cpp	/^void another(void)$/;"	f
arrive	.\queue.h	/^    long arrive;$/;"	m	class:Customer
attempts	.\strc_ref.cpp	/^    int attempts;$/;"	m	struct:free_throws	file:
buy	.\stock00.cpp	/^void Stock::buy(long num,double price)$/;"	f	class:Stock
callme1	.\vegnews.cpp	/^void callme1(StringBad & rsb)$/;"	f
callme2	.\vegnews.cpp	/^void callme2(StringBad sb)$/;"	f
company	.\stock00.h	/^        std::string company;$/;"	m	class:Stock
debts	.\namesp.cpp	/^namespace debts$/;"	n	file:
debts	.\namesp.h	/^namespace debts$/;"	n
dequeue	.\queue.cpp	/^bool Queue::dequeue(Item & item)$/;"	f	class:Queue
display	.\strc_ref.cpp	/^void display(const free_throws & ft)$/;"	f
distance	.\coordin.h	/^    double distance;$/;"	m	struct:polar
enqueue	.\queue.cpp	/^bool Queue::enqueue(const Item & item)$/;"	f	class:Queue
fname	.\namesp.h	/^        std::string fname;$/;"	m	struct:pers::Person
free_throws	.\strc_ref.cpp	/^struct free_throws$/;"	s	file:
front	.\queue.h	/^    Node * front;$/;"	m	class:Queue
getDebt	.\namesp.cpp	/^    void getDebt(Debt & rd)$/;"	f	namespace:debts
getPerson	.\namesp.cpp	/^    void getPerson(Person & rp)$/;"	f	namespace:pers
isempty	.\queue.cpp	/^bool Queue::isempty() const$/;"	f	class:Queue
isfull	.\queue.cpp	/^bool Queue::isfull() const$/;"	f	class:Queue
item	.\queue.h	/^    struct Node { Item item; struct Node * next;};$/;"	m	struct:Queue::Node
items	.\queue.h	/^    int items;$/;"	m	class:Queue
len	.\stmgbad.h	/^        int len;$/;"	m	class:StringBad
lname	.\namesp.h	/^        std::string lname;$/;"	m	struct:pers::Person
made	.\strc_ref.cpp	/^    int made;$/;"	m	struct:free_throws	file:
main	.\bank.cpp	/^int main()$/;"	f
main	.\file1.cpp	/^int main()$/;"	f
main	.\hangman.cpp	/^int main()$/;"	f
main	.\namessp.cpp	/^int main(void)$/;"	f
main	.\shape.cpp	/^int main()$/;"	f
main	.\str1.cpp	/^int main()$/;"	f
main	.\strc_ref.cpp	/^int main()$/;"	f
main	.\strfile.cpp	/^int main()$/;"	f
main	.\test.c	/^int main()$/;"	f
main	.\test.cpp	/^int main()$/;"	f
main	.\usestock0.cpp	/^int main()$/;"	f
main	.\vegnews.cpp	/^int main()$/;"	f
name	.\namesp.h	/^        Person name;$/;"	m	struct:debts::Debt
name	.\strc_ref.cpp	/^    std::string name;$/;"	m	struct:free_throws	file:
newcustomer	.\bank.cpp	/^bool newcustomer(double x)$/;"	f
next	.\queue.h	/^    struct Node { Item item; struct Node * next;};$/;"	m	struct:Queue::Node	typeref:struct:Queue::Node::Node
num_strings	.\stmgbad.cpp	/^int StringBad::num_strings = 0;$/;"	m	class:StringBad	file:
num_strings	.\stmgbad.h	/^        static int num_strings;$/;"	m	class:StringBad
operator <<	.\stmgbad.cpp	/^std::ostream & operator<<(std::ostream & os,const StringBad & st)$/;"	f
operator =	.\queue.h	/^    Queue & operator=(const Queue & q){return *this;}$/;"	f	class:Queue
other	.\namessp.cpp	/^void other(void)$/;"	f
percent	.\strc_ref.cpp	/^    float percent;$/;"	m	struct:free_throws	file:
pers	.\namesp.cpp	/^namespace pers$/;"	n	file:
pers	.\namesp.h	/^namespace pers$/;"	n
polar	.\coordin.h	/^struct polar$/;"	s
processtime	.\queue.h	/^    int processtime;$/;"	m	class:Customer
ptime	.\queue.h	/^    int ptime() const { return processtime;}$/;"	f	class:Customer
put1	.\test.c	/^int put1(const char * string)$/;"	f
qsize	.\queue.h	/^    const int qsize;$/;"	m	class:Queue
queuecount	.\queue.cpp	/^int Queue::queuecount() const$/;"	f	class:Queue
rear	.\queue.h	/^    Node * rear;$/;"	m	class:Queue
rect	.\coordin.h	/^struct rect$/;"	s
rect_to_polar	.\file2.cpp	/^polar rect_to_polar(rect xypos)$/;"	f
sell	.\stock00.cpp	/^void Stock::sell(long num,double price)$/;"	f	class:Stock
set	.\queue.cpp	/^void Customer::set(long when)$/;"	f	class:Customer
set_pc	.\strc_ref.cpp	/^void set_pc(free_throws & ft)$/;"	f
set_tot	.\stock00.h	/^        void set_tot(){total_val = shares * share_val;}$/;"	f	class:Stock
share_val	.\stock00.h	/^        double share_val;$/;"	m	class:Stock
shares	.\stock00.h	/^        long shares;$/;"	m	class:Stock
show	.\stock00.cpp	/^void Stock::show()$/;"	f	class:Stock
showDebt	.\namesp.cpp	/^    void showDebt(const Debt & rd)$/;"	f	namespace:debts
showPerson	.\namesp.cpp	/^    void showPerson(const Person & rp)$/;"	f	namespace:pers
show_polar	.\file2.cpp	/^void show_polar(polar dapos)$/;"	f
str	.\stmgbad.h	/^        char * str;$/;"	m	class:StringBad
sumDebts	.\namesp.cpp	/^    double sumDebts(const Debt ar[],int n)$/;"	f	namespace:debts
total_val	.\stock00.h	/^        double total_val;$/;"	m	class:Stock
update	.\stock00.cpp	/^void Stock::update(double price)$/;"	f	class:Stock
when	.\queue.h	/^    long when() const { return arrive;}$/;"	f	class:Customer
wordlist	.\hangman.cpp	/^const string wordlist[NUM] = {$/;"	v
x	.\coordin.h	/^    double x;$/;"	m	struct:rect
y	.\coordin.h	/^    double y;$/;"	m	struct:rect
~Queue	.\queue.cpp	/^Queue::~Queue()$/;"	f	class:Queue
~StringBad	.\stmgbad.cpp	/^StringBad::~StringBad()$/;"	f	class:StringBad
